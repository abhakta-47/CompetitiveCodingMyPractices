{
	// Place your CompetitiveCodingMyPractices workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cpp cp template": {
		"prefix": "template",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"#define ll long long",
			"#define pb push_back",
			"#define loop(i, x, n) for (int i = x; i < n; i++)",
			"",
			"void sol() {",
			"    ll ${2:n};",
			"    cin >> ${2:n};",
			"    ${3}",
			"",
			"    return;",
			"}",
			"",
			"int main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    cout.tie(NULL);",
			"    int t;",
			"    t = 1;",
			"    ${1}cin >> t;",
			"    for (int i = 0; i < t; i++) {",
			"        // clog << \"Case #\" << i + 1 << \": \\n\";",
			"        sol();",
			"        // clog<<\"\\n\";",
			"        cout << \"\\n\";",
			"    }",
			"}",
			""
		],
		"description": "cpp cp template"
	},
	"graph class": {
		"prefix": "graph",
		"body": [
			"class Graph",
			"{",
			"    int V; // No. of vertices",
			"",
			"    //graph containing vector",
			"    vector<vector<int>> adj;",
			"    vector<bool> visited;",
			"",
			"    // A recursive function used by DFS",
			"    void DFSUtil(int v)",
			"    {",
			"        // Mark the current node as visited and",
			"        // print it",
			"        visited[v] = true;",
			"        // //cout << v << \" ? \" << visited[v] << \" \";",
			"        // Recur for all the vertices adjacent",
			"        // to this vertex",
			"        int i;",
			"        for (i = 0; i < adj[v].size(); ++i)",
			"        {",
			"            // //cout << v << \" -> \" << adj[v][i] << \"\\n\";",
			"            if (!visited[adj[v][i]])",
			"                DFSUtil(adj[v][i]);",
			"        }",
			"    }",
			"",
			"public:",
			"    vector<int> node_distants;",
			"",
			"    Graph(int V) // Constructor",
			"    {",
			"        this->V = V;",
			"        adj.resize(V + 1);",
			"        node_distants.resize(V + 1);",
			"        visited.resize(V + 1, false);",
			"    }",
			"",
			"    void addEdge(int v, int w)",
			"    {",
			"        // //cout << \"joining \" << v << \" \" << w << \" \";",
			"        adj[v].push_back(w); // Add w to vâ€™s list.",
			"        adj[w].push_back(v); // for non-direcrted graph",
			"        // //cout << adj[v].size() << \" \" << adj[v][adj[v].size() - 1] << \" \" << adj[w].size() << \" \" << adj[w][adj[w].size() - 1] << \"\\n\";",
			"    }",
			"",
			"    void visitReset()",
			"    { //reset visit array to zero",
			"        for (int i = 0; i <= V; i++)",
			"            visited[i] = false;",
			"    }",
			"",
			"    void DFS(int v)",
			"    {",
			"        visitReset();",
			"        DFSUtil(v);",
			"    }",
			"",
			"    int nComponents()",
			"    {",
			"        visitReset();",
			"        int k = 0;",
			"        for (int i = 1; i <= V; i++)",
			"        {",
			"            //cout << i << \" = \" << k << \" ? \" << visited[i] << \"\\n\";",
			"",
			"            if (!visited[i])",
			"            {",
			"                DFS(i);",
			"                ++k;",
			"            }",
			"            // for (int i = 0; i <= V; i++)",
			"            //cout << visited[i] << \" \";",
			"            //cout << \"\\n\\n\";",
			"        }",
			"        return k;",
			"    }",
			"",
			"    void BFS(int x)",
			"    {",
			"        visitReset();",
			"        queue<int> temp;",
			"        temp.push(x);",
			"        visited[x] = true;",
			"        while (!temp.empty())",
			"        {",
			"            x = temp.front();",
			"            cout << x << \" -> \";",
			"            temp.pop();",
			"            for (int i = 0; i < adj[x].size(); i++)",
			"            {",
			"                cout << adj[x][i] << \" \";",
			"                if (!visited[adj[x][i]])",
			"                {",
			"                    visited[adj[x][i]] = true;",
			"                    temp.push(adj[x][i]);",
			"                }",
			"            }",
			"            cout << \"\\n\";",
			"        }",
			"    }",
			"",
			"    int minDistance(int s, int e)",
			"    {",
			"        visitReset();",
			"        int i;",
			"        for (i = 0; i <= V; i++)",
			"            node_distants[i] = -1;",
			"        queue<int> temp;",
			"        temp.push(s);",
			"        visited[s] = true;",
			"        node_distants[s] = 0;",
			"        while (!temp.empty())",
			"        {",
			"            s = temp.front();",
			"            // cout << s << \" -> \";",
			"            temp.pop();",
			"            for (int i = 0; i < adj[s].size(); i++)",
			"            {",
			"                // cout << adj[s][i] << \"=\";",
			"                if (!visited[adj[s][i]])",
			"                {",
			"                    visited[adj[s][i]] = true;",
			"                    temp.push(adj[s][i]);",
			"                    node_distants[adj[s][i]] = node_distants[s] + 1;",
			"",
			"                    // if (adj[s][i] == e)",
			"                    //     return node_distants[e];",
			"                }",
			"                // cout << node_distants[adj[s][i]] << \" \";",
			"            }",
			"            // cout << \"\\n\";",
			"        }",
			"",
			"        int k = 0;",
			"        for (i = 1; i < node_distants.size(); i++)",
			"        {",
			"            // cout << i << \"=\" << node_distants[i] << \"\\n\";",
			"            if (node_distants[i] == e)",
			"                ++k;",
			"        }",
			"",
			"        return k;",
			"    }",
			"};",
			"",
			"",
			""
		],
		"description": "graph class"
	},
	"Largest Sum Contiguous Subarray": {
		"prefix": "maxSumContiSubArray",
		"body": [
			"int maxSumContiSubArray(int *a, int size)",
			"{",
			"    int max_so_far = INT_MIN, max_ending_here = 0,",
			"        start = 0, end = 0, s = 0;",
			"",
			"    for (int i = 0; i < size; i++)",
			"    {",
			"        max_ending_here += a[i];",
			"",
			"        if (max_so_far < max_ending_here)",
			"        {",
			"            max_so_far = max_ending_here;",
			"            start = s;",
			"            end = i;",
			"        }",
			"",
			"        if (max_ending_here < 0)",
			"        {",
			"            max_ending_here = 0;",
			"            s = i + 1;",
			"        }",
			"    }",
			"    // cout << \"Maximum contiguous sum is \"",
			"    //      << max_so_far << endl;",
			"    // cout << \"Starting index \" << start",
			"    //      << endl",
			"    //      << \"Ending index \" << end << endl;",
			"    return end - start + 1;",
			"}"
		],
		"description": "Largest Sum Contiguous Subarray"
	}
}